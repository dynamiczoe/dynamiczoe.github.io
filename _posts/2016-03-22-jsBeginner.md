---
layout: post
title:  "[JavaScript] 언어의 기초"
date:   2016-03-22
author: 박정환
categories: JavaScript
tags:	JavaScript
cover:  "/assets/Earth.png"
---

# JS - 3장 (언어의기초)

## 내용
### 문법
* ECMA Script는 대부분 C, JAVA, PERL등에서 차용한 문법이다.
* `대, 소 문자`를 구분 하고
* 식별자는 `문자`나 `$`, `_` 중 하나로 시작하며 유니코드를 사용 할 수 있으나 권장하지않는다
* `카멜케이스 사용`을 권장한다
* 주석은 `//`, `/* */`가 있다.
* 스트릭트모드는 `'use strict';` 를 문서 첫머리에 작성하며, 안전하지않은 동작에는 에러를 반환한다.
* 문장은 `;` 로 끝맺으며, `if`등 블록에서 한줄인 경우에도 `{ }` 를 사용함을 권장한다.

### 변수
* 변수에는 어떤 타입의 데이터든지 저장 할 수 있다.
* 문자열을 담았다가 숫자형을 담을 수 있지만 `권장하지 않음`
* var 연산자를 생략하면 전역변수로 선언할 수 있지만 `권장하지 않음`

### 데이터 타입
* 원시데이터타입 : undefined, null, boolean, 숫자, 문자열
* 객체 = 이름-값 쌍의 순서없는 목록
* typeof 연산자 : 변수의 타입을 확인할 수 있음 - typeof null == Object / 정의되지않은, 초기화되지않은 변수 == undefined
* undefined : 변수를 정의하고 초기화 하지 않은경우 가지는 값. `null`과는 다름 / typeof 연산만이 유의미한 조작임
* null : 빈 객체를 참조하는 값 / 가용하지 않은 객체는 null로 초기화 하는것이 좋다
* boolean : 모든 타입을 boolean으로 변환 할 수 있다. 
	*  true - 0이 아닌 숫자, 공백문자 제외한 문자열, 모든객체
	*  false - 0, nan, null, undefined, 공백문자열
* 숫자형 : 정수와 부동소수점숫자를 포함함. 
	* NaN - 숫자를 반환할 것으로 의도한 값이 숫자가 아닐때. `에러아님`/ 모든 조작에서 NaN을 반환함 
	* number() - 모든 데이터형에 사용가능 / 문자열 변환시 리딩제로 버림 / 16진수 문자가 아닌경우 NaN반환 
	* parseInt() - 정수형으로 변환가능 / 두번째 인자로 radix 주면 혼동을 예방할 수 있음 / 리딩스페이스 제외한 첫문자 + - 숫자가 아닌경우 NaN / 숫자로 시작하면 뒤의 문자열은 버림
	* parseFloat() - 리딩제로 항상무시 / 항상 10진수 / 16진수 넣으면 0 반환
* 문자열 : 불변성 - 항상 새로운 문자열을 채워야함 / 변환 - toString() 하거나 null이나 undefined위험이 있는경우 String()을 사용 String(null) == 'null'
* 객체 : 데이터와 기능의 집합 / 모두 Object타입을 상속받음

### 연산자
* 종류 : 계산연산자, 비트연산자, 관계연산자, 일치연산자
* 단항연산자 : 평가와 증감이 이루어져, 다른연산과 사용하지않는것을 권장.
* 비트연산자 : 64비트형식으로 저장 / 하지만 값을 32비트로 변환하여 비트연산자 적용후 64로 다시 저장하므로 32비트로만 알아도 됨.
* boolean : 
	* 논리 not - !!은 Boolean()과 같은결과를 얻을수 있다.
	* 논리 and - short circuit
		* 객체 && (반환)
		* bool && 객체(반환) - bool == true
		* 객체 && 객체(반환)
		* null(반환) && *
		* NaN(반환) && * 
		* undefined(반환) && *
    * 논리 or - 
	    * 객체(반환) || *
	    * false || *(반환)
	    * 객체(반환) || 객체
	    * null || null - null(반환)
	    * NaN || NaN - NaN(반환)
	    * undefined || undefined - undefined(반환)
* 곱셈 : 
	*  NaN * (뭐든) == NaN
	*  범위 넘어가면 (-)Infinity 
	*  Ifinity * 0 == NaN
	*  둘중하나가 숫자가 아니면 Number()한 후 곱셈함
*  나눗셈 : 
	*  NaN / (뭐든) == NaN
	*  Infinity / Infinity == NaN
	*  0 / 0 == NaN
	*  (숫자) / 0 == (-)Infinity
*  나머지 : 
	*  둘다 숫자면 일반적인 나머지 반환
	*  Infinity % (숫자) == NaN
	*  (숫자) % Infinity == (숫자)
	*  0 % (숫자) == (숫자)
*  덧셈 : 
	*  문자열 + 숫자  == 문자열+String(숫자)
*  뺄셈 : 
	*  숫자 - 문자열 == 숫자 - number(문자열)

* 관계연산자
	* 피연산자가 모두숫자면 숫자형 비교
	* 모두 문자면 서로 대응 하는 문자코드를 앞에서부터 비교
	* 하나만 숫자라면 number()한 후 비교 
* 동일연산자
	* 타입이 다를 경우 형변환을 해서 확인함
	* 둘중 하나가 NaN인경우는 항상 false반환
	* 둘다 객체이면 같은객체를 가리키는지 비교
* 일치연산자
	* 타입이 다를경우 false를 반환

### 문장
* with문
	* using - namespace 같은개념
### 함수
* 매개변수는 배열이다 arguments[] 수가 다르게 넘어가도 에러가 나지 않음
	* arguments[0]으로 접근가능함
	* 이름붙은 매개변수는 arguments[]을 자동참조함
	* arguments[]를 수정하면 이름붙은 매개변수도 자동 반영됨
	* 하지만 그 반대는 동작하지않음. 이름붙은 매개변수만 수정된다
	* 오버로딩이 없다 / 시그니처가 없음 = 매개변수는 그저 배열일 뿐이기 때문 / 두번정의하면 마지막함수가 이름을 소유함

## 어려웠던부분
* 연산자, 타입 변환 함수들이 동작하는 경우의 수가 많았다
* 다른언어와 같은점도 있고 다른점도 있어서 혼동되었다 (==와 ===의 차이)
* 변수에 저장되는 형식도 숫자형이 정수형과 부동소수점 수를 포함해서 나눗셈 연산마다 parseInt해야하는걸 나중에야 알았다
* 변수의 스코프가 블럭스코프가 없어서 조심해야겠다고 생각했다
