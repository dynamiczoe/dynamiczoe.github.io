---
layout: post
title:  "[JavaScript] 언어의 기초"
date:   2016-03-22
author: 박정환
categories: JavaScript
tags:	JavaScript
cover:  "/assets/Earth.png"
---
# JS  - 4장 (변수와 스코프, 메모리)

## 내용
### 원시 값, 참조 값
* 원시 값 
	* 단순한 데이터
	* 숫자, 문자열, null, boolean, undefined
* 참조 값
	* 여러 값으로 구성되는 객체
* 모든 변수는 값으로 접근한다
	* 원시 값 - 데이터 값
	* 참조 값 - 참조하는 heap 영역의 주소


### 동적 프로퍼티
* 참조 값에만 동적으로 프로퍼티나 메서드를 추가하하거나 바꾸고 삭제 할 수 있다
* 하지만 원시 값에 프로퍼티를 추가하려해도 에러가 나지는 않는다
	* 접근시에는 undefined 를 반환함

### 값 복사
* 원시 값 - 현재 저장된 값을 다른 변수에 복사
	* 값 조작에 부작용이 없다(완전히 다른 변수)
* 참조 값 - heap에 저장되어 있는 객체를 가리키는 포인터를 다른 변수에 복사
	* 한쪽에서 변경하면 다른쪽에서도 반영됨
	* heap메모리 - 브라우저가 쓰는 메모리

### 매개변수 전달
* ECMA의 모든 매개변수는 값으로 전달된다
* 함수외부의 값은 내부의 매개변수에 전달됨
* 매개변수는 지역변수 취급
* 한가지 혼동 할 수 있는점
	* 참조 값을 매개변수로 전달시 
	* 동일한 heap 영역을 바라보지만
	* 함수 외부의 값에대한 참조가 아니기때문에
	* 매개변수에 다른 객체를 할당해도
	* 함수 외부의 값은 변하지 않는다

### 타입 판별
* typeof 연산자는 원시타입인지 파악하는데 특화되어 있음
	* 일반적으로 참조값에는 typeof가 쓸모가 없다
	* 객체여부가 중요한게 아니라, 어떤타입의 객체인지는 알 수 없기때문
* 그래서 instanceof 연산자를 사용하여 해당 참조 타입의 인스턴스 인지 판별 가능
	* 모든객체 instanceof Object  => true

### 실행 컨텍스트와 스코프
* 컨텍스트 라고 줄여서 부른다
* 다른 데이터에 접근 할 수 있는지, 어떻게 행동하는지 규정한다
* 변수객체가 연결되어 있다
	* 모든 변수와 함수들이 이 객체에 포함된다
* 가장 바깥의 컨텍스트는 전역 컨텍스트이다
	* 웹 브라우저의 경우 window 라고 부른다
	* 애플리케이션이 종료될때까지 계속 유지된다
* 함수를 호출하면 독자적인 실행컨텍스트가 생성된다
	* 함수로 들어갈때마다 함수의 컨텍스트가  컨텍스트 스택에 쌓인다
	* 함수 실행이 끝나면 해당 컨텍스트를 꺼내고 컨트롤을 반환한다
* 컨텍스트에서 코드를 실행하면 변수 객체에 `스코프체인`이 만들어진다
	* 스코프체인은 실행 컨텍스트가 접근할 수 있는 모든 변수와 함수의 순서를 정의함
	* 컨텍스트가 함수라면 활성화객체(arguments)를 변수객체로 사용한다
	* 변수객체 다음은 부모컨텍스트, 그다음은 부모의 부모 순으로 올라간다
	* 스코프체인은 가장 바깥에 있는 전역컨텍스트까지 도달한다
	* 전역 컨텍스트까지 탐색하였지만 식별자를 찾을 수 없다면 일반적으로 에러가 발생한다
* 일반적으로 바깥의 컨텍스트는 접근 할 수 있지만
* 현재 컨텍스트에서 내부의 컨텍스트는 접근 할 수 없다
* 스코프체인의 순서를 따라 탐색을 진행하므로 로컬 변수가 외부의 변수를 가리는 현상이 나타난다

### 스코프 체인 확장
* 실행 컨텍스트에는 전역 컨텍스트와 함수 컨텍스트 두가지가 있다
* 하지만 임시로 변수 객체를 만드는 문장이 있다
	* try-catch문에서의 catch 블록
	* with문
* 현재 컨텍스트에 임시 변수객체를 추가하므로 함수 컨텍스트내에서 사용 가능 하다

### 블록 레벨 스코프
* 다른 언어와 달리 코드 블록에는 스코프가 없다
* 변수를 추가 할 때마다 해당 변수를 현재 실행 컨텍스트에 추가한다
	* for문에서 선언후 초기화 한 var i=0 같은 경우
	* for문 종료후에도 사용이 가능하다
* var는 자동으로 가장 가까운 컨텍스트에 변수를 추가한다

### 식별자 검색
* 검색은 스코프체인 앞에서 시작하며, 주어진 이름으로 식별자를 찾음
* 로컬 컨텍스트 부터 전역 컨텍스트 까지 거슬러 올라가면서 검색
* 만약 로컬 컨텍스트 에서 식별자가 발견되면 지역변수를 참조할때는 다음 변수 객체를 검색하지 않는다
* 전역 컨텍스트의 color 변수를 이용하려면 window.color라고 명시해야 한다

### GC
* 자바스크립트는 코드 실행중에 메모리를 관리 한다
* GC는 더이상 사용하지 않을 변수를 찾아내서 해당변수가 차지하고 있는 메모리를 회수한다
* 더시상 사용하지 않는 변수를 식별하는 기준은 보통 두가지가 있다
	* 표시하고 지우기
		* 메모리에 저장된 변수 전체에 표시를 남기고
		* 컨텍스트에 있는 변수와 컨텍스트에서 참조하는 변수는 표시를 해제한다
		* 이과정을 거친후 표시가 남아있는 변수들은 삭제해도 안전하다고 판단후 삭제한다
    * 참조 카운팅
	    * 각 값이 얼마나 참조 되었는가를 카운팅한다
	    * 하지만 순환참조라는 심각한 문제가 발생
		    * 순환참조는 자바스크립트상에서는 해결 할 수 있는데
		    * BOM DOM이 자바스크립트 객채로 구현되지않은 IE8이전 버전의 경우
			    * C++  의 COM 으로 구성된 객체들의 순환참조를 해결해 주지 못해 매모리가 회수되지 않았다

### GC의 성능
* 주기적으로 수행되지만 메모리 내에 할당된 변수가 많다면 상당한 비용이 발생한다
* 그래서 수행 타이밍 결정이 중요하다

### 메모리 관리
* 일반적으로 가비지 컬렉션을 지원하면 메모리관리는 크게 신경쓰지 않아도됨
* 하지만 자바스크립트는 가용 메모리가 매우 적다
	* 웹브라우저가 사용할 수 있는 매모리만큼만 가용 하기 때문
	* 자바스크립트가 시스템 메모리를 전부 사용해서 OS를 다운시키는 일을 방지하기 위해
*  그래서 변수할당, 호출스택, 스레드에서 실행할 수 있는 문장수에 영향을 미침
*  최소한의 메모리만 사용해야 성능을 높일 수 있다
*  필요 없어진 대이터에는 null을 할당하여 참조를 제거
	*  주로 전역변수 및 전역 객체의 프로퍼티에 행한다
*  변수에서 참조를 제거한다고 해서 바로 메모리가 반환되지는 않지만
*  GC수행시 반환되도록 하려는 의도에서 수동으로 참조를 제거한다
